#define BLACK_TILE 1
#define WHITE_TILE 0
#define ON_TILE(a) (SENSOR_1 < 50) == a     // 50 is the bound between black and white

#define TURN_SPEED 40          //
#define STRAIGHT_SPEED 50      //

#define TURN_LEFT_PIVOT OUT_B       //
#define TURN_RIGHT_PIVOT OUT_C    //

#define ARC_INC 5              //

#define LOCKUP_WAIT 50        //Wait time between sequential Motor commands, to prevent motor lockup

inline void goStraight(){
    OnFwdSync( OUT_BC, STRAIGHT_SPEED, 0);
}

inline void StopMotors(){
    OffEx(OUT_BC, RESET_ALL);
    Wait(LOCKUP_WAIT);
}

inline int getCurrentTile(){
    return ON_TILE( BLACK_TILE ) ? BLACK_TILE : WHITE_TILE;
}

inline void setup(){
    SetSensorLight(IN_1, true);
    Wait(500);
}

sub move(int dist){
    RotateMotorEx(OUT_BC, STRAIGHT_SPEED, dist*20, 0, true, true);
    StopMotors();
}

sub donutTurn(int degrees, byte pivot){
    RotateMotor(pivot , TURN_SPEED, (degrees*400)/100);// 4 ~ (2*pi*r)/w  where r=11.3 and w=17.7
    StopMotors();
}

void rotateArcDistance(byte pivot, int arcLength, int speed){
    int currArcLength = 0;

    OnFwd( pivot, speed);

    while(currArcLength <= arcLength){
        Wait(ARC_INC);
        currArcLength++;
    }
    StopMotors();
}

int countArcDistance(byte pivot, int currentTile, int speed){
    int arcLength = 0;

    OnFwd( pivot, speed);

    while( ON_TILE ( currentTile ) ){
        Wait(ARC_INC);
        arcLength++;
    }
    StopMotors();

    return arcLength;
}

void alignOnTile(int currentTile ){
    int leftArcDist, rightArcDist, correctionArcDist;
    byte correctionPivot;

    leftArcDist = countArcDistance(TURN_LEFT_PIVOT, currentTile, TURN_SPEED);
    rotateArcDistance(TURN_LEFT_PIVOT, leftArcDist, -TURN_SPEED);
    rightArcDist = countArcDistance(TURN_RIGHT_PIVOT, currentTile, TURN_SPEED);
    rotateArcDistance(TURN_RIGHT_PIVOT, rightArcDist, -TURN_SPEED);

    if (rightArcDist > leftArcDist){
        correctionArcDist = rightArcDist - leftArcDist;
        correctionPivot = TURN_LEFT_PIVOT;
    }else{
        correctionArcDist = leftArcDist - rightArcDist;
        correctionPivot = TURN_RIGHT_PIVOT;
    }
    rotateArcDistance(correctionPivot, (correctionArcDist * 30 )/ 100 , -TURN_SPEED);
}

void alignForFinalStretch(){
    goStraight();
    until( ON_TILE( BLACK_TILE ) ); StopMotors();
    move(5);
    Wait(100);
    donutTurn(90, TURN_RIGHT_PIVOT);

    OnRevSync( OUT_BC, STRAIGHT_SPEED, 0);
    until( ON_TILE( BLACK_TILE ) ); StopMotors();
    OnRevSync( OUT_BC, STRAIGHT_SPEED, 0);
    until( ON_TILE( WHITE_TILE ) ); StopMotors();
    goStraight();
    until( ON_TILE( BLACK_TILE ) ); StopMotors();
}

void crossTiles(int tileColour, int tileLimit){ //needs beter name
     int tileCount = 0;
     while(tileCount < tileLimit){

         if ( getCurrentTile() == tileColour){
            PlayTone(500, 400);
            tileCount++;
            alignOnTile( BLACK_TILE );
            goStraight();
            until( ! ON_TILE( BLACK_TILE ) );
        }else{
            goStraight();
            until( ! ON_TILE ( WHITE_TILE ) );
            Wait(100);
            StopMotors();
        }
    }
}

void getIntoStartingPosition(){
     int currentTile = getCurrentTile();
     goStraight();
     until( ON_TILE( WHITE_TILE ) );
     goStraight();
     until( ON_TILE( BLACK_TILE ) );
     PlayTone(500, 400);
     move(4);
     donutTurn(90, TURN_RIGHT_PIVOT);
}

task main(){
    setup();
    getIntoStartingPosition();
    crossTiles(BLACK_TILE, 13); //change this to 13
    alignForFinalStretch();
    crossTiles(BLACK_TILE, 8);
}
