#define ON_TILE(a) (SENSOR_1 < 50) == a     // 50 is the bound between black and white
#define BLACK_TILE 1                        //
#define WHITE_TILE 0                        //

#define TURN_SPEED 40
#define STRAIGHT_SPEED 50
#define TURN_LEFT_PIVOT OUT_B
#define TURN_RIGHT_PIVOT OUT_C
#define ARC_INC 5                           //
#define LOCKUP_WAIT 50                      //Wait time between sequential Motor commands, to prevent motor lockup

#define GO_BACKWARDS OnRevSync(OUT_BC, STRAIGHT_SPEED, 0)
#define GO_FORWARDS OnFwdSync(OUT_BC, STRAIGHT_SPEED, 0)
#define STOP_MOTORS OffEx(OUT_BC, RESET_ALL); Wait(LOCKUP_WAIT)
#define CURRENT_TILE (ON_TILE( BLACK_TILE ) ? BLACK_TILE : WHITE_TILE)

sub move(int dist){
    RotateMotorEx(OUT_BC, STRAIGHT_SPEED, dist*20, 0, true, true);
    STOP_MOTORS;
}
sub donutTurn(int degrees, byte pivot){
    RotateMotor(pivot , TURN_SPEED, (degrees*400)/100);// 4 ~ (2*pi*r)/w  where r=11.3 and w=17.7.
    STOP_MOTORS;
}

void rotateArcDistance(byte pivot, int arcLength, int speed){
    int currArcLength = 0;

    OnFwd( pivot, speed);
    while(currArcLength <= arcLength){
        Wait(ARC_INC);
        currArcLength++;
    }
    STOP_MOTORS;
}
int countArcDistance(byte pivot, int currentTile, int speed){
    int arcLength = 0;

    OnFwd( pivot, speed);
    while( ON_TILE ( currentTile ) ){
        Wait(ARC_INC);
        arcLength++;
    }
    STOP_MOTORS;
    return arcLength;
}

void alignOnTile(int currentTile ){
    int leftArcDist, rightArcDist, correctionArcDist;
    byte correctionPivot;

    leftArcDist = countArcDistance(TURN_LEFT_PIVOT, currentTile, TURN_SPEED);
    rotateArcDistance(TURN_LEFT_PIVOT, leftArcDist, -TURN_SPEED);
    rightArcDist = countArcDistance(TURN_RIGHT_PIVOT, currentTile, TURN_SPEED);
    rotateArcDistance(TURN_RIGHT_PIVOT, rightArcDist, -TURN_SPEED);

    if (rightArcDist > leftArcDist){
        correctionArcDist = rightArcDist - leftArcDist;
        correctionPivot = TURN_LEFT_PIVOT;
    }else{
        correctionArcDist = leftArcDist - rightArcDist;
        correctionPivot = TURN_RIGHT_PIVOT;
    }
    rotateArcDistance(correctionPivot, (correctionArcDist * 32 )/ 100 , -TURN_SPEED);
}
void crossTiles(int tileColour, int tileLimit){ //needs beter name
     int tileCount = 0;
     while(tileCount < tileLimit){
         if (CURRENT_TILE == tileColour){
            PlayTone(500, 400);
            tileCount++;
            alignOnTile( BLACK_TILE );
            GO_FORWARDS; until( ON_TILE( WHITE_TILE ) );
        } else {
            GO_FORWARDS; until( ON_TILE ( BLACK_TILE ) );
            Wait(100);
            STOP_MOTORS;
        }
    }
}

inline void alignForEnd(){
}
inline void alignForMiddle(){
    GO_FORWARDS; until( ON_TILE( BLACK_TILE ) ); STOP_MOTORS;
    move(5);
    Wait(100);
    donutTurn(90, TURN_RIGHT_PIVOT);

    GO_BACKWARDS; until( ON_TILE( BLACK_TILE ) );
    GO_BACKWARDS; until( ON_TILE( WHITE_TILE ) ); STOP_MOTORS;
    GO_FORWARDS; until( ON_TILE( BLACK_TILE ) ); STOP_MOTORS;
}
inline void alignForStart(){
     int currentTile = CURRENT_TILE;
     GO_FORWARDS; until( ON_TILE( WHITE_TILE ) );
     GO_FORWARDS; until( ON_TILE( BLACK_TILE ) );
     PlayTone(500, 400);
     move(4);
     donutTurn(90, TURN_RIGHT_PIVOT);
}

task main(){
    SetSensorLight(IN_1, true);
    alignForStart();
    crossTiles(BLACK_TILE, 13); //change this to 13
    alignForMiddle();
    crossTiles(BLACK_TILE, 8);
    alignForEnd();
}
