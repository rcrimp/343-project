#define BLACK_MAX 50           //light values to be computed at runtime

#define BLACK_TILE 1
#define WHITE_TILE 0
#define ON_TILE(a) (SENSOR_1 < BLACK_MAX) == a

#define TURN_SPEED 40          //
#define STRAIGHT_SPEED 40      //

#define ROT_LEFT_PIV 100       //
#define ROT_RIGHT_PIV -100     //

#define ARC_INC 5              //

#define LOCKUP_WAIT 100        //Wait time between sequential Motor commands, to prevent motor lockup

inline void turnOffMotors(){
      OffEx(OUT_BC, RESET_ALL);
      Wait(LOCKUP_WAIT);
}

void setup() {
     SetSensorLight(IN_1, true);
     Wait(500);
}

void rotateArcLength(int pivot, int arcLength){
     int currArcLength = 0;

     OnFwdSync(OUT_BC, TURN_SPEED, pivot);
     while(currArcLength <= arcLength){
       Wait(ARC_INC);
       currArcLength++;
     }
     turnOffMotors();
}

int countArcLength(int pivot, int tileColour){ //needs better name
     int arcLength = 0;

     OnFwdSync(OUT_BC, TURN_SPEED, pivot);
     while( ON_TILE(tileColour) ){
       Wait(ARC_INC);
       arcLength++;
     }
     turnOffMotors();

     return arcLength;
}

void alignOnTile(int tileColour){
     int leftDistance, rightDistance;

     leftDistance = countArcLength(ROT_LEFT_PIV, tileColour);
     rotateArcLength(ROT_RIGHT_PIV, leftDistance);
     rightDistance = countArcLength(ROT_RIGHT_PIV, tileColour);
     rotateArcLength(ROT_LEFT_PIV, rightDistance);

     if (rightDistance > leftDistance) {
         rotateArcLength(ROT_RIGHT_PIV, (rightDistance - leftDistance) );
     } else {
         rotateArcLength(ROT_LEFT_PIV, (leftDistance - rightDistance) );
     }
}

task main(){
     setup();

     while(true){

         alignOnTile(BLACK_TILE);
         OnFwdSync(OUT_BC, STRAIGHT_SPEED, 0);
         while(SENSOR_1 < BLACK_MAX){}

         alignOnTile(WHITE_TILE);
         OnFwdSync(OUT_BC, STRAIGHT_SPEED, 0);
         while(SENSOR_1 > BLACK_MAX){}
     }
}
