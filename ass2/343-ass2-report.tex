\documentclass[a4paper,11pt]{article}
\title{COSC343 Assignment 2 - Report}
\author{Reuben Crimp}
\date{\today}
\addtolength{\oddsidemargin}{-.5in}
\addtolength{\evensidemargin}{-.5in}
\addtolength{\textwidth}{1in}

\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}
%\pagestyle{empty} % no page numbers
\usepackage[T1]{fontenc}

\usepackage{color}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}
\usepackage{listings}
\lstset{language=Java,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  basicstyle=\ttfamily
  %moredelim=[il][\textcolor{pgrey}]{$$},
  %moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}


\begin{document}
\maketitle

\section*{Genetic Algorithm}
My Genetic Algorithm is fairly simple, there are a few fancy tricks here and there, but on the whole it conforms to an expected Genetic Algorithm.

There are several values which dictate the overall performance, they are
\begin{itemize}
  \item Board Size, the chess board sides length (default = 8)
  \item Population Size, the number of elements the GA operates on (default = 100)
  \item Max Generations, is the largest number of generations the GA will perform before restarting
  \item MAX RESTARTS = 10;
  \item KEEP RATIO = 0.20;
  \item MUTATION P = 0.05;
\end{itemize}

\subsection*{Initial Population}
My method ensures that each element in the initial population has no vertical or horizontal collisions whilst maintaing uniform variance. This means that the GA can find a solution very fast as each element starts off very fit. 

Vertical collsions are impossble when using the recomended data structure. board permutations with horizontal collisions are omitted by ensuring every number from 1 to 8 appears in the data structure, i.e. every column is occupied by 1 and only 1 queen.
\subsection*{Population Stagnation}
If every elements in the population converges to the same element, we essentially start breeding clones only to get more clones. The decreasing variance in the population means deriving a solution may never happen.

My method combats the likely decrease in varaiance in several ways.
\subsubsection*{1 Mutatation}
For each child that we add to our populatin there is a chance that the any of the values in the array will ``mutate'' to any random value between 1-8. This increasing variance in individual elements.
\subsubsection*{2 Random Immigrants}
We can at any point add new elements to the population, since new elements are created with uniform variance, adding will almost always increase the variance of the population.
Exactly when and where we add them is described below.
\subsubsection*{3 Don't Breed if Clones}
Before breeding parents, check how similar they are, if they are identical then we replace one with a random immigrant. We can now breed the two parents with a greatly decreased chance of introducing a clone to the population.
\subsubsection*{4 Multi Start}
If after a certain number of generations a solution has yet to be found, reset the entire population. So if any of the above methods fail to prevent stagnation for the current run, then we can start again. This is more of a fail safe and does not usually gets executed.

\subsection*{Crossover Methods}
\subsection*{Parent Selection Methods}

\section*{Experiments}
a description of expirimentation success with various settings.
\subsection*{Crossover Methods}

several methods were tested

two parents, with a single random crossover point
two parents, with uniform crossover,
i.e each gene of the child has equal chance of coming from either parent.
two parents, with a single crossover point, where the crossover point derived from the fitness of the parents.
i.e if both parents have equal fitness, then the crossover is in the middle
if one parent is more fit than the other than the crossover point is biased towards allowing more of the fit parents genes into the ch
ild.
random number of parents, between 2 and 8, with random number of crossover points (1-7)

when testing breeding techniques, I used a ranked round robin parent selection method, no mutating only breeding.
I testing each method 1 million times, stop if solution was found, if generations > 1 million assume failure 


I have chosen a single split crossover, where the splitpoint is a derived from the parents fitness, because this method was least likely to cause population stagnation and fail

single split random crossover
failed with probability 0.45028...
uniformly distributed crossover
failed with probability 0.30652... 
single split crossover, derived from parents fitness
failed with probability 0.25567...
three parent crossover
failed with probability 0.34903...
random parent crossover
failed with probability 0.5932...
\subsection*{Parent Selection Methods}
I tried several methods of parent selection

For most methods I fitst sorted the population by fitness, this allowed the parent selection method to choose parents base on their relative fitness with ease.

purely stochastic, any random parent

round robin, i.e. every single unorderd pair
then replacing the lower half of the sorted population with the best children.  
succesive pairs, chosen from the sorted population
which would breed pairs with exact fitness.
interleaving pairs, i.e choosing only odd parents from the sorted list
which would breed pairs with similar fitness.
choosing pairs which are seperated by half of the populaton in the sorted list
which ensures one parent far more fit than the other.

successive pairs almost always failed, especialy without population stagnation protection, I didn't bother officially testing it.

interleaving pairs performed surprisingly well, same with 

\section*{Best Solution}
Results of the best run, presented in a table or graph as the fitness/cost of the best solution for each generation/population.
i.e graph the most fit over the generations

\section*{The Code}
\addtolength{\oddsidemargin}{-.5in}
\addtolength{\evensidemargin}{-.5in}
\begin{lstlisting}
  import java.util.*;
  import java.lang.Math;
  
  public class Nqueen{
    /* settings, with default values */
    public static int BOARD_SIZE = 8;
    public static int POPULATION = 100;
    public static int MAX_GENERATIONS = 100;
    public static int MAX_RESTARTS = 10;
    public static double KEEP_RATIO = 0.20;
    public static double MUTATION_P = 0.05;

    public static List<Board> boards;

    /* main */
    public static void main(String[] args){
      int c = 0;
      while(c < args.length) { //read args in pairs
        String temp = args[c++];
        if(c < args.length)
        parseArg(temp, args[c++]); //parse the pair of args
      }
      System.err.println("Begining the Genetic Algorithm with the following settings:" +
      "\textbackslash nboard size:\textbackslash t" + BOARD_SIZE +
      "\textbackslash npopulation:\textbackslash t" + POPULATION +
      "\textbackslash ngenerations:\textbackslash t" + MAX_GENERATIONS +
      "\textbackslash nrestarts:   \textbackslash t" + MAX_RESTARTS +
      "\textbackslash nkeep ratio: \textbackslash t" + KEEP_RATIO +
      "\textbackslash nmutation p: \textbackslash t" + MUTATION_P + "\textbackslash n");

        /************************************************************************/
        int generations = 0;
        int resets = 0;
        
        boards = new ArrayList<Board>();
        for(int i = 0; i < POPULATION; i++){
          boards.add(new Board()); // fill the list with random elements
        }
        
        while(getBest().fitness > 0){
          /* reorder the list before breeding, optional */
          sort();
          // shuffle();

          /* breed the elements */
          breedRandom();
          // breedEveryPair();
          // breedEverySecondPair();
          // breedPairs();

          /* if we exceed the generation limit restart */
          if(generations++ > MAX_GENERATIONS && resets < 10){ 
            resetAll();
            generations = 0;
            resets++;
          }
        }

        /* print the best board when done */
        System.err.println(getBest().toStringPretty());
        System.out.println((resets*MAX_GENERATIONS + generations));
    }

    /* resets all elements in the population back to random elements */
    public static void resetAll(){
      for(int i = 0; i < POPULATION; i++)
      boards.set(i, new Board());
    }

    /* chooses successive pairs of elements in the list to breed */
    public static void breedPairs(){
      int numParents = Math.max(2,(int)(KEEP_RATIO*POPULATION));
      int numChildren = POPULATION - numParents;
      for(int i = 0; i < numChildren; i++){
        boards.set(numParents + i,
        crossover_weighted_split(i % numParents, (i+1) % numParents));
      }
    }
    /* breed only the even elements in the list in successive pairs */
    public static void breedEverySecondPair(){
      for(int i = 0; i < POPULATION; i+=4){
        boards.set(i+1, crossover_weighted_split(i, i+2));
        boards.set(i+3, crossover_weighted_split(i+2, i));
      }
    }
    /* chooses parents at random, then breeds the with random crossovers */
    public static void breedRandom(){
      int numParents = Math.max(2,(int)(KEEP_RATIO*POPULATION));
      int numChildren = POPULATION - numParents;
      int r1, r2;
      for(int i = 0; i < numChildren; i++){
        r1 = (int)(Math.random()*numParents);
        r2 = (int)(Math.random()*numParents);
        while (r1 == r2)
        r2 = (int)(Math.random()*numParents);
        boards.set(numParents + i,
        crossover_random_split(r1, r2));
      }
    }

    /* takes the indices of two parents, and breeds them with a single random split point  */
    public static Board crossover_random_split(int p1, int p2){
      Board parent1 = boards.get(p1);
      Board parent2 = boards.get(p2);
      //ensure we aren't breeding duplicates
      if(p1 != p2 && parent1.sameBoardAs(parent2))
      return new Board();
      int splitPoint = (int)(Math.random() * (BOARD_SIZE-1));
      return new Board(parent1, parent2, splitPoint);
    }
    /* takes the indices of two parents, and breeds them with a splitpoint derived from the parents fitness */
    public static Board crossover_weighted_split(int p1, int p2){
      Board parent1 = boards.get(p1);
      Board parent2 = boards.get(p2);
      //ensure we aren't breeding duplicates
      if(p1 != p2 && parent1.sameBoardAs(parent2))
      return new Board(); 
      int splitPoint = (int)((Math.min(parent1.fitness, parent2.fitness) /
      (double)Math.max(parent1.fitness, parent2.fitness)) * (BOARD_SIZE-1));
      return new Board(parent1, parent2, splitPoint);
    }
    /* takes the indices of two parents, and breeds them a uniform crossover method */
    public static Board crossover_uniform(int p1, int p2){
      Board parent1 = boards.get(p1);
      Board parent2 = boards.get(p2);
      //ensure we aren't breeding duplicates
      if(p1 != p2 && parent1.sameBoardAs(parent2))
      return new Board(); 
      return new Board(parent1, parent2);
    }

    /* finds the most fit elements and returns it */
    public static Board getBest(){
      Board best = boards.get(0);
      for(int i = 1; i < POPULATION; i+=1)
      if(boards.get(i).fitness < best.fitness)
      best = boards.get(i);
      return best;
    }

    /* shuffles the list of boards, very simple shuffle*/
    public static void shuffle(){
      Random random = new Random();
      for(int i = POPULATION-1; i > 0; i--){
        int index = random.nextInt(i+1);
        Board temp = boards.get(index);  //swap(index, i)
        boards.set(index, boards.get(i));
        boards.set(i, temp);
      }
    }
    /* sorts the list of boards */
    public static void sort(){
      Collections.sort(boards, new Comparator<Board>(){
        @Override
        public int compare(Board v1, Board v2) {
          return v1.compareTo(v2);
        }
      });
    }

    public static void parseArg(String type, String value){}
    public static int stringToInt(String s){}
    public static double stringToDouble(String s){}
  }

  /* a Board object describes a particular board permutation using an array
  * 
  * 
  */
  class Board {
    public int[] array; //the board permutation is stored this array
    public int fitness; //the fitness

    /* this constructor makes a random board permutation */
    public Board(){
      array = new int[Nqueen.BOARD_SIZE];
      for(int i = 0; i < Nqueen.BOARD_SIZE; i++)
      array[i] = i; //array = {1, 2, .. 8}
      shuffle();
      fitness = calcFitness();
    }
    /* this constructor creates a board from 2 other 'parent' boards
    uses single point crossover point */
    public Board(Board parent1, Board parent2, int splitPoint){    
      array = new int[Nqueen.BOARD_SIZE];
      for(int i = 0; i < Nqueen.BOARD_SIZE; i++){
        if(i <= splitPoint)
        array[i] = parent1.array[i];
        else
        array[i] = parent2.array[i];
      }
      mutate();
      fitness = calcFitness();
    }
    /* this constructor creates a board from 2 other 'parent' boards
    uses a uniform distribution crossover method */
    public Board(Board parent1, Board parent2){
      array = new int[Nqueen.BOARD_SIZE];
      Board best = (parent1.fitness > parent2.fitness) ? parent1 : parent2;
      Board worst = (parent1.fitness < parent2.fitness) ? parent1 : parent2;
      double p = best.fitness / (worst.fitness + best.fitness);
      
      for(int i = 0; i < Nqueen.BOARD_SIZE; i++){
        if(Math.random() < p)
        array[i] = best.array[i];
        else
        array[i] = worst.array[i];
      }
      mutate();
      fitness = calcFitness();
    }                  

    /* mutate the board */
    private void mutate(){
      for(int n = 0; n < Nqueen.BOARD_SIZE; n++){
        if(Math.random() < Nqueen.MUTATION_P){
          array[n] = (int)(Math.random() * Nqueen.BOARD_SIZE);
        }
      }
    }
    
    /* calculates the fitness as a count of un-orderd attacking pairs of queens
    best fitness = 0
    worst fitness = 8 choose 2 = 28
    */
    private int calcFitness(){
      int attackingPairs = 0;
      for(int i = 0; i < Nqueen.BOARD_SIZE; i++)
      attackingPairs += countEast(i) + countSouthEast(i) + countNorthEast(i);
      return attackingPairs;
    }
    //count the queens horizontally left (east) of the current piece
    private int countEast(int start){
      int result = 0;
      for(int i = start+1; i < Nqueen.BOARD_SIZE; i++)
      if (array[i] == array[start])
      result++;                        
      return result;
    }
    private int countNorthEast(int start){
      int result = 0;
      for(int i = start+1; i < Nqueen.BOARD_SIZE; i++)
      if (array[i] == array[start]-i+start)
      result++;
      return result;
    }
    private int countSouthEast(int start){
      int result = 0;
      for(int i = start+1; i < Nqueen.BOARD_SIZE; i++)
      if (array[i] == array[start]+i-start)
      result++;
      return result;
    }

    /* shuffles the array, simple knuth shuffle */
    private void shuffle(){
      Random random = new Random();
      for(int i = Nqueen.BOARD_SIZE-1; i > 0; i--){
        int index = random.nextInt(i+1);
        int temp = array[index];
        array[index] = array[i];
        array[i] = temp;
      }
    }

    /* compareTo required for sort */
    public int compareTo(Board v2){
      double tmp = this.fitness - v2.fitness;
      return (tmp > 0) ? 1 : (tmp < 0) ? -1 : 0;
    }

    /* used to determine if this is identical to another board */
    public bool sameBoardAs(Board board2){
      int count = 0;
      for(int i = 0; i < Nqueen.BOARD_SIZE; i++)
      if (array[i] == board2.array[i])
      count++;
      return (count == Nqueen.BOARD_SIZE)
    }

    /* nice string representation of the board, in a nice grid */
    public String toStringPretty(){
      String grid = "";
      for(int col = 0; col < Nqueen.BOARD_SIZE; col++){
        grid += "|";
        for(int row = 0; row < Nqueen.BOARD_SIZE; row++){
          if(array[row] == col)
          grid += "Q|";
          else
          grid += "_|";
        }
        if(col+1 < Nqueen.BOARD_SIZE)
        grid += "\textbackslash n";
      }
      return toString() + "\textbackslash n" + grid + "\textbackslash nfitness: " + fitness;
    }

    /* simple string representation of the board */
    public String toString(){
      String s = "[";
        for(int col = 0; col < Nqueen.BOARD_SIZE; col++){
          s += (array[col]+1);
          if(col+1 < Nqueen.BOARD_SIZE)
          s += ",";
        }
        return s + "]";
    }
  }
\end{lstlisting}

\end{document}
